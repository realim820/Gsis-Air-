tmsã€wmsã€wmtsã€åæ ‡ç³»ï¼ˆ3857ã€4490ã€4326ï¼‰ã€leafletã€openlayer

# **ä¸€ã€[WebGIS](https://zhida.zhihu.com/search?content_id=223660928&content_type=Article&match_order=1&q=WebGIS&zhida_source=entity)**

Webå°±æ˜¯ç½‘é¡µç«¯ï¼ŒGISå…¨ç§°æ˜¯[åœ°ç†ä¿¡æ¯ç³»ç»Ÿ](https://zhida.zhihu.com/search?content_id=223660928&content_type=Article&match_order=1&q=åœ°ç†ä¿¡æ¯ç³»ç»Ÿ&zhida_source=entity)ï¼›æ‰€ä»¥WebGISç³»ç»Ÿå°±æ˜¯ç½‘é¡µç«¯çš„åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼Œç®€å•ç‚¹è¯´å°†åœ°ç†ç©ºé—´ä¿¡æ¯ä»¥åœ°å›¾çš„æ–¹å¼åœ¨ç½‘é¡µç«¯å±•ç°å‡ºæ¥ï¼Œåšå¯è§†åŒ–æˆ–è€…æ˜¯[ç©ºé—´åˆ†æ](https://zhida.zhihu.com/search?content_id=223660928&content_type=Article&match_order=1&q=ç©ºé—´åˆ†æ&zhida_source=entity)åŠŸèƒ½ã€‚

# äºŒã€WMS(ç½‘ç»œåœ°å›¾æœåŠ¡)ã€WMTS(ç½‘ç»œåœ°å›¾ç“¦ç‰‡æœåŠ¡)ã€TMS(ç“¦ç‰‡åœ°å›¾æœåŠ¡)

Webåœ°å›¾æœåŠ¡è§„èŒƒåŒ…æ‹¬WMS(ç½‘ç»œåœ°å›¾æœåŠ¡)ã€WMTS(ç½‘ç»œåœ°å›¾ç“¦ç‰‡æœåŠ¡)ã€TMS(ç“¦ç‰‡åœ°å›¾æœåŠ¡)ç­‰ã€‚WMTSæœåŠ¡å’ŒWMSæœåŠ¡éƒ½æ˜¯ç”±å¼€å‘åœ°ç†ä¿¡æ¯è”ç›Ÿ(OGC)æŒ‡å®šã€‚å…¶ä¸åŒåœ¨äºï¼ŒWMTSæœåŠ¡é‡‡ç”¨ç¼“å­˜æŠ€æœ¯èƒ½å¤Ÿç¼“è§£WebGisæœåŠ¡å™¨ç«¯æ•°æ®å¤„ç†çš„å‹åŠ›ã€‚TMSæœåŠ¡ç”±å¼€æºç©ºé—´ä¿¡æ¯åŸºé‡‘ä¼š(OSGEO)æŒ‡å®šã€‚TMSä¸WMTSæœåŠ¡çš„å·®å¼‚ä¸»è¦ä½“ç°åœ¨:

TMSæ˜¯çº¯Restfulï¼Œè€ŒWMTSå¯ä»¥æœ‰KVPã€SOAPå’ŒRestfulä¸‰ç§ã€‚
TMSç“¦ç‰‡æ˜¯æ­£æ–¹å½¢çš„ï¼Œè€ŒWMTSæ˜¯çŸ©å½¢çš„ï¼ˆæ­£æ–¹å½¢æ˜¯ç‰¹æ®Šçš„çŸ©å½¢ï¼‰
åœ¨çºµè½´æ–¹å‘ä¸Šæ–¹å‘ç›¸åï¼ŒTMSç“¦ç‰‡ä»¥å·¦ä¸‹è§’ä¸ºåŸç‚¹ï¼ŒWMTSç“¦ç‰‡ä»¥å·¦ä¸Šè§’ä¸ºåŸç‚¹ã€‚
WMTSä¸­å¯¹åº”çš„ä¸åŒæ¯”ä¾‹å°ºç“¦ç‰‡å¯ä»¥å°ºå¯¸ä¸åŒã€‚
åœ¨åœ°å›¾æœåŠ¡ä¸­ï¼Œä¸ºäº†å¤„ç†æ–¹ä¾¿ï¼Œç“¦ç‰‡å‡é‡‡ç”¨æ­£æ–¹å½¢ï¼Œä¸€èˆ¬åƒç´ ä¸º256ï¼ˆå±…å¤šï¼‰æˆ–è€…512ã€‚

**è¿™å‘¨å¯ä»¥åšä¸‹è¿™ä¸¤ä¸ªä»»åŠ¡:**
**1.geoserverå‘å¸ƒtms  wmtsç“¦ç‰‡æœåŠ¡**
**2.é€šè¿‡openlayeræˆ–leafletå®ç°ç“¦ç‰‡æœåŠ¡çš„åŠ è½½æ˜¾ç¤ºï¼Œæä¾›æ¯”ä¾‹å°ºï¼Œç»çº¬åº¦ç­‰å°ç»„ä»¶çš„æ˜¾ç¤ºï¼Œå¯ä»¥åŸºäºvueç¼–å†™**

è¿›åº¦ï¼š

**å­¦ä¹ å®‰è£…éƒ¨ç½²geoserverå’Œä¸Šä¼ ã€é…ç½®ã€å‘å¸ƒã€åœ°å›¾å›¾å±‚**

http://localhost:8080/geoserver

é»˜è®¤è´¦æˆ·åadminï¼Œå¯†ç geoserver

[å‡ ä¸ªshapeæ ¼å¼ã€tiffæ ¼å¼åœ°å›¾å…è´¹ä¸‹è½½ç½‘ç«™_åœ°å›¾tif ä¸‹è½½-CSDNåšå®¢](https://blog.csdn.net/sunnyloves/article/details/45618089)

## å‰ç«¯ï¼š

```bash
npm create vite@latest wmts-demo -- --template vue
cd wmts-demo
npm install
```

æŠ¥é”™å¦‚ä¸‹ï¼š

```bash
error when starting dev server: TypeError: crypto.hash is not a function    at getHash (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/chunks/dep-DZ2tZksn.js:2788:21)    at getLockfileHash (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/chunks/dep-DZ2tZksn.js:11673:9)    at getDepHash (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/chunks/dep-DZ2tZksn.js:11676:23)    at initDepsOptimizerMetadata (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/chunks/dep-DZ2tZksn.js:11137:53)    at createDepsOptimizer (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/chunks/dep-DZ2tZksn.js:34586:17)    at new DevEnvironment (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/chunks/dep-DZ2tZksn.js:35350:109)    at Object.defaultCreateClientDevEnvironment [as createEnvironment] (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/chunks/dep-DZ2tZksn.js:35769:9)    at _createServer (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/chunks/dep-DZ2tZksn.js:28344:132)    at async CAC.<anonymous> (file:///F:/Desktop/geo/geodemo/front-end/wmts-demo/node_modules/vite/dist/node/cli.js:573:18) PS F:\Desktop\geo\geodemo\front-end\wmts-demo> 
```

ç–‘ä¼¼nodeç‰ˆæœ¬çš„é—®é¢˜ï¼Œé«˜ç‰ˆæœ¬viteä¸ä½ç‰ˆæœ¬nodeä¹‹é—´æœ‰é—®é¢˜ï¼ˆnode.jsç‰ˆæœ¬ä¸ºv21.5)

æŠ¥äº†ä¸€å¤§å †é”™ï¼Œ**å‘ç°å’Œåˆ‡ç‰‡çš„èŒƒå›´æœ‰å…³ï¼š**
![image-20250715112804162](./assets/image-20250715112804162.png)

### leaflet:

```vue
<template>
  <div class="leaflet-wmts-container">
    <h3>ğŸ“ Leaflet WMTS åœ°å›¾æœåŠ¡</h3>
    
    <div class="leaflet-controls">
      <button @click="initializeMap" :disabled="mapInitialized" class="btn-primary">
        {{ mapInitialized ? 'âœ… åœ°å›¾å·²åˆå§‹åŒ–' : 'ğŸ—ºï¸ åˆå§‹åŒ–åœ°å›¾' }}
      </button>
      <button @click="testWMTSConnection" class="btn-info">
        ğŸ”§ æµ‹è¯• WMTS è¿æ¥
      </button>
      <button @click="loadWMTSLayer" :disabled="!mapInitialized" class="btn-success">
       b ğŸ¢ åŠ è½½ WMTS å›¾å±‚
      </button>
      <button @click="loadOSMLayer" :disabled="!mapInitialized" class="btn-info">
        ğŸŒ åŠ è½½ OSM åº•å›¾
      </button>
      <button @click="clearLayers" :disabled="!mapInitialized" class="btn-warning">
        ğŸ—‘ï¸ æ¸…é™¤å›¾å±‚
      </button>
    </div>
    
    <div class="layer-controls">
      <div class="control-group">
        <label>WMTS å›¾å±‚åç§°:</label>
        <select v-model="wmtsLayerName">
          <option value="ne:countries">ne:countries (å›½å®¶è¾¹ç•Œ)</option>
          <option value="nurc:mosaic">nurc:mosaic (æ …æ ¼æ•°æ®)</option>
          <option value="chinademo1:buildings">chinademo1:buildings (ä¸­å›½å»ºç­‘)</option>
          <option value="topp:states">topp:states (ç¾å›½å·ç•Œ)</option>
        </select>
        <input v-model="wmtsLayerName" placeholder="æˆ–æ‰‹åŠ¨è¾“å…¥å›¾å±‚åç§°" style="margin-top: 5px;" />
      </div>
      
      <div class="control-group">
        <label>ç“¦ç‰‡æ ¼å¼:</label>
        <select v-model="tileFormat">
          <option value="image/png">PNG</option>
          <option value="image/jpeg">JPEG</option>
          <option value="image/webp">WebP</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>åæ ‡ç³»:</label>
        <select v-model="crs" @change="onCRSChange">
          <option value="EPSG:4326">EPSG:4326 (WGS84)</option>
          <option value="EPSG:3857">EPSG:3857 (Web Mercator)</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>å›¾å±‚é€æ˜åº¦:</label>
        <input type="range" v-model="layerOpacity" min="0" max="1" step="0.1" />
        <span>{{ layerOpacity }}</span>
      </div>
    </div>
    
    <!-- åœ°å›¾å®¹å™¨ -->
    <div ref="mapContainer" class="leaflet-map"></div>
    
    <!-- å¿«é€Ÿå®šä½æŒ‰é’® -->
    <div class="quick-locations" v-if="mapInitialized">
      <h5>ğŸ¯ å¿«é€Ÿå®šä½</h5>
      <div class="location-buttons">
        <button @click="flyToLocation(116.4, 39.9, 10)" class="location-btn">
          ğŸ›ï¸ åŒ—äº¬
        </button>
        <button @click="flyToLocation(121.5, 31.2, 10)" class="location-btn">
          ğŸ™ï¸ ä¸Šæµ·
        </button>
        <button @click="flyToLocation(113.3, 23.1, 10)" class="location-btn">
          ğŸŒº å¹¿å·
        </button>
        <button @click="flyToLocation(104.1, 30.7, 10)" class="location-btn">
          ğŸ¼ æˆéƒ½
        </button>
      </div>
    </div>
    
    <!-- çŠ¶æ€ä¿¡æ¯ -->
    <div class="status-panel">
      <h5>ğŸ“Š çŠ¶æ€ä¿¡æ¯</h5>
      <div class="status-grid">
        <div class="status-item">
          <span class="label">åœ°å›¾çŠ¶æ€:</span>
          <span class="value" :class="mapInitialized ? 'success' : 'pending'">
            {{ mapInitialized ? 'å·²åˆå§‹åŒ–' : 'æœªåˆå§‹åŒ–' }}
          </span>
        </div>
        <div class="status-item">
          <span class="label">å½“å‰ä¸­å¿ƒ:</span>
          <span class="value">{{ currentCenter }}</span>
        </div>
        <div class="status-item">
          <span class="label">ç¼©æ”¾çº§åˆ«:</span>
          <span class="value">{{ currentZoom }}</span>
        </div>
        <div class="status-item">
          <span class="label">åŠ è½½çš„å›¾å±‚:</span>
          <span class="value">{{ loadedLayers.join(', ') || 'æ— ' }}</span>
        </div>
      </div>
    </div>
    
    <!-- é”™è¯¯ä¿¡æ¯ -->
    <div v-if="errorMessage" class="error-panel">
      <h5>âš ï¸ é”™è¯¯ä¿¡æ¯</h5>
      <pre>{{ errorMessage }}</pre>
      <button @click="clearError" class="btn-danger">æ¸…é™¤é”™è¯¯</button>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, watch } from 'vue'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'

// å“åº”å¼æ•°æ®
const mapContainer = ref(null)
const mapInitialized = ref(false)
const wmtsLayerName = ref('ne:countries') // ä½¿ç”¨ç¡®å®å­˜åœ¨çš„å›¾å±‚
const tileFormat = ref('image/png')
const crs = ref('EPSG:4326')
const layerOpacity = ref(0.8)
const currentCenter = ref('')
const currentZoom = ref(0)
const loadedLayers = ref([])
const errorMessage = ref('')

// åœ°å›¾å’Œå›¾å±‚å®ä¾‹
let map = null
let wmtsLayer = null
let osmLayer = null

// åˆå§‹åŒ–åœ°å›¾
const initializeMap = () => {
  try {
    if (map) {
      map.remove()
    }
    
    // æ ¹æ®é€‰æ‹©çš„åæ ‡ç³»åˆ›å»ºåœ°å›¾
    const mapOptions = {
      center: crs.value === 'EPSG:4326' ? [35, 105] : [39.9, 116.4],
      zoom: 6,
      zoomControl: true,
      attributionControl: true
    }
    
    // å¦‚æœæ˜¯ EPSG:4326ï¼Œä½¿ç”¨ç‰¹æ®Šçš„ CRS
    if (crs.value === 'EPSG:4326') {
      mapOptions.crs = L.CRS.EPSG4326
    }
    
    map = L.map(mapContainer.value, mapOptions)
    
    // ç›‘å¬åœ°å›¾äº‹ä»¶
    map.on('moveend', updateMapInfo)
    map.on('zoomend', updateMapInfo)
    
    // æ·»åŠ æ¯”ä¾‹å°º
    L.control.scale().addTo(map)
    
    // æ·»åŠ åæ ‡æ˜¾ç¤º
    const coordsControl = L.control({ position: 'bottomleft' })
    coordsControl.onAdd = function() {
      const div = L.DomUtil.create('div', 'coords-control')
      div.style.background = 'rgba(255,255,255,0.8)'
      div.style.padding = '5px'
      div.style.borderRadius = '3px'
      div.innerHTML = 'ç§»åŠ¨é¼ æ ‡æŸ¥çœ‹åæ ‡'
      return div
    }
    coordsControl.addTo(map)
    
    // é¼ æ ‡ç§»åŠ¨æ˜¾ç¤ºåæ ‡
    map.on('mousemove', (e) => {
      const coords = map.getContainer().querySelector('.coords-control')
      if (coords) {
        coords.innerHTML = `ç»åº¦: ${e.latlng.lng.toFixed(6)}, çº¬åº¦: ${e.latlng.lat.toFixed(6)}`
      }
    })
    
    mapInitialized.value = true
    updateMapInfo()
    clearError()
    
    console.log('Leaflet åœ°å›¾åˆå§‹åŒ–æˆåŠŸ')
    
  } catch (error) {
    errorMessage.value = `åœ°å›¾åˆå§‹åŒ–å¤±è´¥: ${error.message}`
    console.error('åœ°å›¾åˆå§‹åŒ–é”™è¯¯:', error)
  }
}

// åŠ è½½ WMTS å›¾å±‚
const loadWMTSLayer = () => {
  try {
    if (!map) return
    
    // ç§»é™¤ç°æœ‰çš„ WMTS å›¾å±‚
    if (wmtsLayer) {
      map.removeLayer(wmtsLayer)
    }
    
    // æ„å»º WMTS URL æ¨¡æ¿
    const wmtsUrl = buildWMTSUrl()
    
    console.log('WMTS URL:', wmtsUrl)
    
    // åˆ›å»º WMTS å›¾å±‚
    wmtsLayer = L.tileLayer(wmtsUrl, {
      attribution: 'GeoServer WMTS',
      opacity: parseFloat(layerOpacity.value),
      maxZoom: 18,
      tileSize: 256,
      // é”™è¯¯å¤„ç†
      errorTileUrl: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZmZmIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iI2NjYyIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPuaXoOazleWKoOi9vTwvdGV4dD48L3N2Zz4='
    })
    
    // ç›‘å¬å›¾å±‚äº‹ä»¶
    wmtsLayer.on('loading', () => {
      console.log('WMTS å›¾å±‚å¼€å§‹åŠ è½½')
    })
    
    wmtsLayer.on('load', () => {
      console.log('WMTS å›¾å±‚åŠ è½½å®Œæˆ')
      if (!loadedLayers.value.includes('WMTS')) {
        loadedLayers.value.push('WMTS')
      }
    })
    
    wmtsLayer.on('tileerror', (e) => {
      console.error('ç“¦ç‰‡åŠ è½½é”™è¯¯:', e)
      console.error('é”™è¯¯çš„ç“¦ç‰‡åæ ‡:', e.coords)
      console.error('ç“¦ç‰‡URL:', e.tile.src)
      
      // è¯¦ç»†é”™è¯¯ä¿¡æ¯
      let errorDetail = 'æœªçŸ¥é”™è¯¯'
      if (e.error && e.error.target) {
        errorDetail = `HTTP é”™è¯¯: ${e.error.target.status || 'Network Error'}`
      }
      
      errorMessage.value = `ç“¦ç‰‡åŠ è½½é”™è¯¯ [${e.coords.z}/${e.coords.x}/${e.coords.y}]: ${errorDetail}\nURL: ${e.tile.src}`
    })
    
    // æ·»åŠ åˆ°åœ°å›¾
    wmtsLayer.addTo(map)
    
    clearError()
    
  } catch (error) {
    errorMessage.value = `WMTS å›¾å±‚åŠ è½½å¤±è´¥: ${error.message}`
    console.error('WMTS å›¾å±‚åŠ è½½é”™è¯¯:', error)
  }
}

// æ„å»º WMTS URL æ¨¡æ¿ - ä¿®å¤ç‰ˆæœ¬
const buildWMTSUrl = () => {
  const baseUrl = 'http://localhost:8080/geoserver/gwc/service/wmts'
  
  // æ„å»º URL æ¨¡æ¿ï¼Œæ³¨æ„ {z}, {x}, {y} ä¸è¦è¢« encodeURIComponent ç¼–ç 
  const url = `${baseUrl}?` +
    `SERVICE=WMTS&` +
    `REQUEST=GetTile&` +
    `VERSION=1.0.0&` +
    `LAYER=${encodeURIComponent(wmtsLayerName.value)}&` +
    `STYLE=&` +
    `TILEMATRIXSET=${encodeURIComponent(crs.value)}&` +
    `FORMAT=${encodeURIComponent(tileFormat.value)}&` +
    `TILEMATRIX=${encodeURIComponent(crs.value)}:{z}&` +
    `TILEROW={y}&` +
    `TILECOL={x}`
  
  console.log('æ„å»ºçš„ WMTS URL æ¨¡æ¿:', url)
  return url
}

// åŠ è½½ OSM å›¾å±‚
const loadOSMLayer = () => {
  try {
    if (!map) return
    
    // ç§»é™¤ç°æœ‰çš„ OSM å›¾å±‚
    if (osmLayer) {
      map.removeLayer(osmLayer)
    }
    
    // åˆ›å»º OSM å›¾å±‚
    osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors',
      opacity: 0.7,
      maxZoom: 19
    })
    
    osmLayer.addTo(map)
    
    if (!loadedLayers.value.includes('OSM')) {
      loadedLayers.value.push('OSM')
    }
    
    clearError()
    
  } catch (error) {
    errorMessage.value = `OSM å›¾å±‚åŠ è½½å¤±è´¥: ${error.message}`
    console.error('OSM å›¾å±‚åŠ è½½é”™è¯¯:', error)
  }
}

// æ¸…é™¤æ‰€æœ‰å›¾å±‚
const clearLayers = () => {
  if (wmtsLayer) {
    map.removeLayer(wmtsLayer)
    wmtsLayer = null
  }
  
  if (osmLayer) {
    map.removeLayer(osmLayer)
    osmLayer = null
  }
  
  loadedLayers.value = []
}

// é£è¡Œåˆ°æŒ‡å®šä½ç½®
const flyToLocation = (lng, lat, zoom = 10) => {
  if (map) {
    map.flyTo([lat, lng], zoom, {
      duration: 1.5
    })
  }
}

// æ›´æ–°åœ°å›¾ä¿¡æ¯
const updateMapInfo = () => {
  if (map) {
    const center = map.getCenter()
    currentCenter.value = `${center.lng.toFixed(4)}, ${center.lat.toFixed(4)}`
    currentZoom.value = map.getZoom()
  }
}

// åæ ‡ç³»å˜åŒ–å¤„ç†
const onCRSChange = () => {
  if (mapInitialized.value) {
    // é‡æ–°åˆå§‹åŒ–åœ°å›¾ä»¥åº”ç”¨æ–°çš„åæ ‡ç³»
    initializeMap()
  }
}

// æ¸…é™¤é”™è¯¯
const clearError = () => {
  errorMessage.value = ''
}

// ç›‘å¬å›¾å±‚é€æ˜åº¦å˜åŒ–
watch(layerOpacity, (newOpacity) => {
  if (wmtsLayer) {
    wmtsLayer.setOpacity(parseFloat(newOpacity))
  }
})

// æµ‹è¯• WMTS è¿æ¥
const testWMTSConnection = async () => {
  try {
    clearError()
    console.log('æµ‹è¯• WMTS è¿æ¥...')
    
    // 1. æµ‹è¯• GetCapabilities
    const capabilitiesUrl = 'http://localhost:8080/geoserver/gwc/service/wmts?REQUEST=GetCapabilities'
    console.log('æµ‹è¯• GetCapabilities:', capabilitiesUrl)
    
    const response = await fetch(capabilitiesUrl)
    if (!response.ok) {
      throw new Error(`GetCapabilities å¤±è´¥: ${response.status} ${response.statusText}`)
    }
    
    const xmlText = await response.text()
    console.log('GetCapabilities æˆåŠŸè·å–')
    
    // 2. æµ‹è¯•å…·ä½“çš„ç“¦ç‰‡URL
    const testTileUrl = buildWMTSUrl()
      .replace('{z}', '1')
      .replace('{x}', '1') 
      .replace('{y}', '0')
    
    console.log('æµ‹è¯•ç“¦ç‰‡URL:', testTileUrl)
    
    const tileResponse = await fetch(testTileUrl)
    if (tileResponse.ok) {
      console.log('âœ… ç“¦ç‰‡æµ‹è¯•æˆåŠŸ!')
      errorMessage.value = 'âœ… WMTS è¿æ¥æµ‹è¯•æˆåŠŸï¼å¯ä»¥æ­£å¸¸åŠ è½½ç“¦ç‰‡ã€‚'
    } else {
      console.log('âŒ ç“¦ç‰‡æµ‹è¯•å¤±è´¥:', tileResponse.status)
      errorMessage.value = `âŒ ç“¦ç‰‡æµ‹è¯•å¤±è´¥: ${tileResponse.status} ${tileResponse.statusText}\nå¯èƒ½åŸå› : å›¾å±‚ä¸å­˜åœ¨æˆ–ç“¦ç‰‡è¶…å‡ºèŒƒå›´`
    }
    
  } catch (error) {
    console.error('WMTS è¿æ¥æµ‹è¯•å¤±è´¥:', error)
    errorMessage.value = `âŒ WMTS è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`
  }
}

// ç»„ä»¶æŒ‚è½½æ—¶è‡ªåŠ¨åˆå§‹åŒ–åœ°å›¾
onMounted(() => {
  console.log('Leaflet WMTS ç»„ä»¶å·²æŒ‚è½½')
  // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ç¡®ä¿ DOM æ¸²æŸ“å®Œæˆ
  setTimeout(initializeMap, 100)
})

// ç»„ä»¶å¸è½½æ—¶æ¸…ç†åœ°å›¾
onUnmounted(() => {
  if (map) {
    map.remove()
  }
})
</script>

<style scoped>
.leaflet-wmts-container {
  padding: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 10px;
  margin: 20px 0;
}

.leaflet-wmts-container h3 {
  color: white;
  margin: 0 0 20px 0;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.leaflet-controls {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
  flex-wrap: wrap;
}

.leaflet-controls button {
  padding: 8px 16px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.3s;
}

.btn-primary { background: #007bff; color: white; }
.btn-success { background: #28a745; color: white; }
.btn-info { background: #17a2b8; color: white; }
.btn-warning { background: #ffc107; color: #212529; }
.btn-danger { background: #dc3545; color: white; }

.leaflet-controls button:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.leaflet-controls button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.layer-controls {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-radius: 8px;
  backdrop-filter: blur(10px);
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.control-group label {
  color: white;
  font-weight: 500;
  font-size: 14px;
}

.control-group input,
.control-group select {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
}

.control-group input[type="range"] {
  background: transparent;
}

.leaflet-map {
  width: 100%;
  height: 500px;
  border-radius: 8px;
  box-shadow: 0 8px 25px rgba(0,0,0,0.3);
  margin-bottom: 20px;
}

.quick-locations {
  background: rgba(255,255,255,0.1);
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 15px;
  backdrop-filter: blur(10px);
}

.quick-locations h5 {
  color: white;
  margin: 0 0 10px 0;
}

.location-buttons {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.location-btn {
  padding: 6px 12px;
  background: rgba(255,255,255,0.2);
  color: white;
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
  font-size: 12px;
}

.location-btn:hover {
  background: rgba(255,255,255,0.3);
  transform: scale(1.05);
}

.status-panel {
  background: rgba(255,255,255,0.1);
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 15px;
  backdrop-filter: blur(10px);
}

.status-panel h5 {
  color: white;
  margin: 0 0 10px 0;
}

.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
}

.status-item {
  display: flex;
  justify-content: space-between;
  padding: 8px 12px;
  background: rgba(255,255,255,0.1);
  border-radius: 4px;
}

.status-item .label {
  color: rgba(255,255,255,0.8);
  font-size: 12px;
}

.status-item .value {
  color: white;
  font-weight: 500;
  font-size: 12px;
}

.value.success { color: #90EE90; }
.value.pending { color: #FFD700; }

.error-panel {
  background: rgba(220, 53, 69, 0.1);
  border: 1px solid rgba(220, 53, 69, 0.3);
  padding: 15px;
  border-radius: 8px;
  backdrop-filter: blur(10px);
}

.error-panel h5 {
  color: #ff6b6b;
  margin: 0 0 10px 0;
}

.error-panel pre {
  background: rgba(0,0,0,0.2);
  color: #ffcccb;
  padding: 10px;
  border-radius: 4px;
  overflow-x: auto;
  font-size: 12px;
  margin: 10px 0;
}

/* å…¨å±€ Leaflet æ ·å¼è¦†ç›– */
:deep(.leaflet-control-attribution) {
  background: rgba(255,255,255,0.8);
  backdrop-filter: blur(5px);
}

:deep(.leaflet-control-scale-line) {
  background: rgba(255,255,255,0.8);
  backdrop-filter: blur(5px);
}

:deep(.coords-control) {
  font-family: monospace;
  font-size: 12px;
  border: 1px solid rgba(0,0,0,0.2);
}
</style>

```

![image-20250717091444229](./assets/image-20250717091444229.png)

### openlayer:

```vue
<template>
  <div>
    <h2>GeoServer WMTS æµ‹è¯•</h2>
    <div ref="mapRef" class="map-container"></div>

    <div class="controls">
      <div class="control-group">
        <label>é€‰æ‹©å›¾å±‚ï¼š</label>
        <select v-model="layerName" @change="onLayerChange">
          <option value="">-- è¯·é€‰æ‹©å›¾å±‚ --</option>
          <option v-for="layer in availableLayers" :key="layer.name" :value="layer.name">
            {{ layer.name }} - {{ layer.title }}
          </option>
        </select>
        <button @click="getCapabilities">ğŸ”„ åˆ·æ–°å›¾å±‚åˆ—è¡¨</button>
      </div>
      
      <div class="control-group">
        <label>æˆ–æ‰‹åŠ¨è¾“å…¥ï¼š</label>
        <input v-model="layerName" placeholder="è¾“å…¥å›¾å±‚åï¼Œå¦‚ ne:countries" />
        <button @click="loadLayer">åŠ è½½å›¾å±‚</button>
      </div>
      
      <div class="status-info">
        <p><strong>çŠ¶æ€:</strong> {{ status }}</p>
        <p v-if="layerInfo"><strong>å½“å‰å›¾å±‚:</strong> {{ layerInfo }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import Map from 'ol/Map'
import View from 'ol/View'
import TileLayer from 'ol/layer/Tile'
import WMTS from 'ol/source/WMTS'
import OSM from 'ol/source/OSM'
import { get as getProjection } from 'ol/proj'
import WMTSCapabilities from 'ol/format/WMTSCapabilities'
import { optionsFromCapabilities } from 'ol/source/WMTS'
import { ScaleLine, MousePosition, defaults as defaultControls } from 'ol/control'
import { createStringXY } from 'ol/coordinate'

const mapRef = ref(null)
const layerName = ref('') 
const status = ref('åˆå§‹åŒ–ä¸­...')
const availableLayers = ref([])
const layerInfo = ref('')
let map = null
let wmtsLayer = null
let osmLayer = null

// è·å–å¯ç”¨å›¾å±‚åˆ—è¡¨
const getCapabilities = async () => {
  status.value = 'è·å–å›¾å±‚åˆ—è¡¨ä¸­...'
  try {
    const response = await fetch('http://localhost:8080/geoserver/gwc/service/wmts?REQUEST=GetCapabilities')
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }
    
    const text = await response.text()
    const parser = new WMTSCapabilities()
    const capabilities = parser.read(text)
    
    // è§£æå›¾å±‚ä¿¡æ¯
    const layers = []
    if (capabilities.Contents && capabilities.Contents.Layer) {
      capabilities.Contents.Layer.forEach(layer => {
        layers.push({
          name: layer.Identifier,
          title: layer.Title || layer.Identifier,
          formats: layer.Format || [],
          tileMatrixSets: layer.TileMatrixSetLink ? 
            layer.TileMatrixSetLink.map(link => link.TileMatrixSet) : []
        })
      })
    }
    
    availableLayers.value = layers
    status.value = `å‘ç° ${layers.length} ä¸ªå¯ç”¨å›¾å±‚`
    
    // å¦‚æœæ²¡æœ‰é€‰ä¸­å›¾å±‚ä¸”æœ‰å¯ç”¨å›¾å±‚ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
    if (!layerName.value && layers.length > 0) {
      layerName.value = layers[0].name
    }
    
  } catch (error) {
    status.value = `è·å–å›¾å±‚åˆ—è¡¨å¤±è´¥: ${error.message}`
    console.error('è·å– capabilities é”™è¯¯:', error)
  }
}

// å›¾å±‚é€‰æ‹©å˜åŒ–å¤„ç†
const onLayerChange = () => {
  if (layerName.value) {
    loadLayer()
  }
}

const loadLayer = async () => {
  if (!layerName.value) {
    status.value = 'è¯·è¾“å…¥å›¾å±‚å'
    return
  }

  status.value = `åŠ è½½å›¾å±‚ ${layerName.value} ä¸­...`

  try {
    const response = await fetch('http://localhost:8080/geoserver/gwc/service/wmts?REQUEST=GetCapabilities')
    const text = await response.text()

    const parser = new WMTSCapabilities()
    const capabilities = parser.read(text)

    const options = optionsFromCapabilities(capabilities, {
      layer: layerName.value,
      matrixSet: 'EPSG:4326', // ä¼˜å…ˆä½¿ç”¨ EPSG:4326
    })

    if (!options) {
      // å¦‚æœ EPSG:4326 ä¸å¯ç”¨ï¼Œå°è¯• EPSG:3857
      const options3857 = optionsFromCapabilities(capabilities, {
        layer: layerName.value,
        matrixSet: 'EPSG:3857',
      })
      
      if (!options3857) {
        throw new Error('å›¾å±‚ä¸æ”¯æŒ EPSG:4326 æˆ– EPSG:3857 åæ ‡ç³»')
      }
      
      const source = new WMTS({
        ...options3857,
        crossOrigin: 'anonymous',
      })

      wmtsLayer.setSource(source)
      
      // åˆ‡æ¢åˆ° EPSG:3857 æŠ•å½±
      map.setView(new View({
        projection: 'EPSG:3857',
        center: [11700000, 4200000], // ä¸­å›½ä¸­å¿ƒ (Web Mercator)
        zoom: 5,
      }))
      
      layerInfo.value = `${layerName.value} (EPSG:3857)`
      
    } else {
      const source = new WMTS({
        ...options,
        crossOrigin: 'anonymous',
      })

      wmtsLayer.setSource(source)

      // ä½¿ç”¨ EPSG:4326 æŠ•å½±
      map.setView(new View({
        projection: 'EPSG:4326',
        center: [105, 35], // ä¸­å›½ä¸­å¿ƒ
        zoom: 5,
      }))
      
      layerInfo.value = `${layerName.value} (EPSG:4326)`
    }

    status.value = `å›¾å±‚ ${layerName.value} åŠ è½½æˆåŠŸ`

  } catch (e) {
    status.value = `å›¾å±‚åŠ è½½å¤±è´¥: ${e.message}`
    console.error(e)
  }
}

onMounted(() => {
  // åˆ›å»º OSM åº•å›¾
  osmLayer = new TileLayer({
    source: new OSM(),
    opacity: 0.6
  })
  
  // åˆ›å»º WMTS å›¾å±‚
  wmtsLayer = new TileLayer({
    opacity: 0.8
  })

  map = new Map({
    target: mapRef.value,
    layers: [osmLayer, wmtsLayer],
    view: new View({
      projection: 'EPSG:4326',
      center: [105, 35],
      zoom: 5,
    }),
    controls: defaultControls().extend([
      // æ¯”ä¾‹å°º
      new ScaleLine({
        units: 'metric',
        className: 'ol-scale-line',
      }),
      // åæ ‡æ˜¾ç¤º
      new MousePosition({
        coordinateFormat: createStringXY(4),
        projection: 'EPSG:4326',
        className: 'ol-mouse-position',
        undefinedHTML: '&nbsp;',
      }),
    ]),
  })

  status.value = 'åœ°å›¾åˆå§‹åŒ–å®Œæˆ'
  
  // è‡ªåŠ¨è·å–å›¾å±‚åˆ—è¡¨
  getCapabilities()
})
</script>

<style scoped>
.map-container {
  width: 100%;
  height: 600px;
  border: 2px solid #007bff;
  border-radius: 8px;
  margin-bottom: 20px;
  position: relative;
}

.controls {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  padding: 20px;
  border-radius: 8px;
  border: 1px solid #dee2e6;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.control-group {
  margin-bottom: 15px;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.control-group label {
  font-weight: 500;
  color: #495057;
  min-width: 80px;
}

.control-group select {
  min-width: 300px;
  padding: 8px 12px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  background: white;
  font-size: 14px;
}

.control-group input {
  min-width: 300px;
  padding: 8px 12px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  font-size: 14px;
}

.control-group button {
  padding: 8px 16px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s;
}

.control-group button:hover {
  background: #0056b3;
}

.status-info {
  margin-top: 15px;
  padding: 15px;
  background: white;
  border-radius: 4px;
  border-left: 4px solid #007bff;
}

.status-info p {
  margin: 5px 0;
  color: #495057;
}

/* OpenLayers æ§ä»¶æ ·å¼ */
:deep(.ol-scale-line) {
  bottom: 8px;
  left: 8px;
  background: rgba(255, 255, 255, 0.9);
  border-radius: 4px;
  padding: 2px 8px;
  border: 1px solid rgba(0, 0, 0, 0.2);
  font-family: 'Segoe UI', sans-serif;
  font-size: 12px;
  color: #333;
}

:deep(.ol-mouse-position) {
  top: 8px;
  right: 8px;
  background: rgba(255, 255, 255, 0.9);
  border-radius: 4px;
  padding: 8px 12px;
  border: 1px solid rgba(0, 0, 0, 0.2);
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 12px;
  color: #333;
  min-width: 160px;
  text-align: center;
}

:deep(.ol-attribution) {
  bottom: 4px;
  right: 4px;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 4px;
  font-size: 10px;
}

:deep(.ol-zoom) {
  top: 8px;
  left: 8px;
}

:deep(.ol-zoom .ol-zoom-in),
:deep(.ol-zoom .ol-zoom-out) {
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  margin: 2px;
  color: #333;
}

:deep(.ol-zoom .ol-zoom-in:hover),
:deep(.ol-zoom .ol-zoom-out:hover) {
  background: #007bff;
  color: white;
}

/* ç¡®ä¿åœ°å›¾æ–‡å­—å¯è§ */
:deep(.ol-overlay-container) {
  color: #333 !important;
}

:deep(.ol-control) {
  color: #333 !important;
}
</style>

```

**æŠ¥é”™è¯´æ˜ï¼š****æ‰‹åŠ¨å†™æ­»çš„ `tileGrid` é…ç½®ä¸ä¸€å®šåŒ¹é… GeoServer çš„ WMTS è®¾ç½®**ï¼Œè¿™æ˜¯å¯¼è‡´ 400 é”™çš„æ ¸å¿ƒåŸå› ä¹‹ä¸€ã€‚

ç‰¹åˆ«æ˜¯ï¼š

1. `resolutions` ä¸åŒ¹é… GeoServer å®é™…å‘å¸ƒçš„åˆ†è¾¨ç‡ã€‚
2. `matrixIds` ä¸ GeoServer `TileMatrix` ä¸ä¸€è‡´ï¼ˆæ¯”å¦‚ EPSG:4326:4 å¼€å§‹ï¼Œè€Œä½ çš„ä»£ç å¯èƒ½ä» EPSG:4326:8 å¼€å§‹ï¼‰ã€‚
3. GeoServer WMTS é€šå¸¸ä» `EPSG:4326:0` å¼€å§‹ï¼Œä¸”æ¯ä¸€çº§ç¼©å°ä¸€åŠï¼ŒOpenLayers å¿…é¡»å®Œå…¨åŒ¹é…å®ƒã€‚

------

âœ… æœ€ä½³å®è·µï¼šä» GeoServer çš„ Capabilities ä¸­åŠ¨æ€åˆ›å»º WMTS é…ç½®

ä½ åº”è¯¥ä½¿ç”¨ OpenLayers å®˜æ–¹æ¨èçš„æ–¹å¼ï¼š

```
tså¤åˆ¶ç¼–è¾‘import WMTSCapabilities from 'ol/format/WMTSCapabilities'
import { optionsFromCapabilities } from 'ol/source/WMTS'

// åŠ è½½å¹¶è§£æ capabilities
const fetchCapabilitiesAndCreateLayer = async (layerName) => {
  const url = 'http://localhost:8080/geoserver/gwc/service/wmts?REQUEST=GetCapabilities'
  const res = await fetch(url)
  const text = await res.text()
  const parser = new WMTSCapabilities()
  const capabilities = parser.read(text)

  const options = optionsFromCapabilities(capabilities, {
    layer: layerName,
    matrixSet: 'EPSG:4326'
  })

  return new WMTS({
    ...options,
    crossOrigin: 'anonymous',
  })
}
```

ç„¶åä½ å¯ä»¥è¿™æ ·ç”¨ï¼š

```vue
const layer = await fetchCapabilitiesAndCreateLayer('chinademo1:buildings')
wmtsLayer.setSource(layer)
```

è¿™æ ·å°±èƒ½é¿å…æ‰€æœ‰æ‰‹åŠ¨æ„é€ é”™è¯¯ã€‚

------

**âœ… å¦‚ä½•åœ¨ä½ çš„ä»£ç ä¸­æ”¹åŠ¨æœ€å°åœ°é›†æˆè¿™ä¸ªé€»è¾‘**

ä½ åªéœ€è¦ä¿®æ”¹è¿™ä¸¤ä¸ªå‡½æ•°ï¼š

#### 1. æ›¿æ¢ `createGeoServerWMTS(...)`ï¼š

å°†å®ƒæ”¹æˆå¦‚ä¸‹ï¼ˆå¼‚æ­¥ç‰ˆæœ¬ï¼‰ï¼š

```vue
import WMTSCapabilities from 'ol/format/WMTSCapabilities'
import { optionsFromCapabilities } from 'ol/source/WMTS'

const createGeoServerWMTS = async (layerName, format = 'image/png', matrixSet = 'EPSG:4326') => {
  const capabilitiesUrl = 'http://localhost:8080/geoserver/gwc/service/wmts?REQUEST=GetCapabilities'
  const res = await fetch(capabilitiesUrl)
  const text = await res.text()
  const parser = new WMTSCapabilities()
  const capabilities = parser.read(text)

  const options = optionsFromCapabilities(capabilities, {
    layer: layerName,
    matrixSet: matrixSet,
  })

  return new WMTS({
    ...options,
    crossOrigin: 'anonymous',
  })
}
```

------

#### 2. ä¿®æ”¹ `testLayer(...)`ï¼Œé€‚é… asyncï¼š

ä½ åŸæœ¬æ˜¯åŒæ­¥åˆ›å»º sourceï¼Œæ”¹æˆè¿™æ ·ï¼š

```vue
const testLayer = async (layer) => {
  status.value = `æµ‹è¯•å›¾å±‚: ${layer.name}...`
  currentLayer.value = layer.name
  currentLayerInfo.value = layer

  try {
    const bestFormat = layer.formats?.includes('image/png') ? 'image/png' : layer.formats?.[0] || 'image/png'
    const bestMatrixSet = layer.tileMatrixSets?.includes('EPSG:4326') ? 'EPSG:4326' : layer.tileMatrixSets?.[0]

    const newSource = await createGeoServerWMTS(layer.name, bestFormat, bestMatrixSet)
    wmtsLayer.setSource(newSource)

    map.setView(new View({
      projection: 'EPSG:4326',
      center: [105, 35],
      zoom: 6
    }))

    if (layer.bounds) {
      map.getView().fit(layer.bounds, {
        padding: [50, 50, 50, 50],
        maxZoom: 10
      })
    }

    status.value = `${layer.name} åŠ è½½æˆåŠŸ`

  } catch (error) {
    status.value = `å›¾å±‚åŠ è½½å¤±è´¥: ${error.message}`
    console.error(error)
  }
}
```

------

**âœ… æ•ˆæœ**

è¿™æ ·ä½ ï¼š

- å†ä¹Ÿä¸éœ€è¦æ‰‹åŠ¨ç®¡ç† `tileGrid`
- ä¸ä¼šå‡ºç° 400 é”™è¯¯ï¼ˆå› ä¸ºé…ç½®å®Œå…¨åŒ¹é… capabilitiesï¼‰
- å…¼å®¹å¤šä¸ªåæ ‡ç³»ã€å›¾å±‚å’Œæ ¼å¼

![image-20250717091423790](./assets/image-20250717091423790.png)

## åç«¯æœåŠ¡

**Qgis(å¼€æº)ã€globalmapperï¼ˆç ´è§£ï¼‰**

